<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>CoPilot Trading - Analyse Temps R√©el 500‚Ç¨</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        :root {
            --primary: #2563eb;
            --secondary: #7c3aed;
            --success: #10b981;
            --danger: #ef4444;
            --warning: #f59e0b;
            --dark: #1f2937;
            --light: #f9fafb;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: linear-gradient(135deg, #0f172a 0%, #1e293b 100%);
            min-height: 100vh;
            color: #333;
        }

        .container {
            max-width: 1600px;
            margin: 0 auto;
            padding: 20px;
        }

        .main-header {
            background: white;
            border-radius: 20px;
            padding: 25px;
            margin-bottom: 20px;
            box-shadow: 0 10px 40px rgba(0,0,0,0.1);
        }

        .header-top {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 20px;
        }

        .header-title {
            font-size: 24px;
            font-weight: 700;
            color: var(--dark);
        }

        .live-indicator {
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .live-dot {
            width: 8px;
            height: 8px;
            background: var(--success);
            border-radius: 50%;
            animation: pulse 2s infinite;
        }

        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.5; }
        }

        .stats-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
            gap: 15px;
            margin-bottom: 20px;
        }

        .stat-card {
            background: #f8f9fa;
            padding: 15px;
            border-radius: 10px;
            text-align: center;
        }

        .stat-label {
            font-size: 11px;
            color: #6b7280;
            text-transform: uppercase;
            margin-bottom: 5px;
        }

        .stat-value {
            font-size: 20px;
            font-weight: 700;
            color: var(--dark);
        }

        .positive { color: var(--success); }
        .negative { color: var(--danger); }

        .main-grid {
            display: grid;
            grid-template-columns: 2fr 1fr;
            gap: 20px;
        }

        @media (max-width: 1200px) {
            .main-grid {
                grid-template-columns: 1fr;
            }
        }

        .card {
            background: white;
            border-radius: 15px;
            padding: 20px;
            box-shadow: 0 5px 20px rgba(0,0,0,0.1);
        }

        .card-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 20px;
            padding-bottom: 15px;
            border-bottom: 2px solid #e5e7eb;
        }

        .card-title {
            font-size: 18px;
            font-weight: 600;
            color: var(--dark);
        }

        .crypto-item, .stock-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 12px;
            background: #f9fafb;
            border-radius: 8px;
            margin-bottom: 10px;
            cursor: pointer;
            transition: all 0.3s;
        }

        .crypto-item:hover, .stock-item:hover {
            background: #e5e7eb;
            transform: translateX(5px);
        }

        .asset-info {
            flex: 1;
        }

        .asset-symbol {
            font-weight: 700;
            font-size: 16px;
            color: var(--dark);
        }

        .asset-name {
            font-size: 12px;
            color: #6b7280;
        }

        .asset-price {
            text-align: right;
        }

        .price-value {
            font-size: 16px;
            font-weight: 600;
            color: var(--dark);
        }

        .price-change {
            font-size: 12px;
            font-weight: 600;
            margin-top: 3px;
        }

        .btn {
            padding: 10px 20px;
            border: none;
            border-radius: 8px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s;
            font-size: 14px;
        }

        .btn-primary {
            background: var(--primary);
            color: white;
        }

        .btn-success {
            background: var(--success);
            color: white;
        }

        .btn-danger {
            background: var(--danger);
            color: white;
        }

        .btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(0,0,0,0.2);
        }

        .portfolio-item {
            background: linear-gradient(135deg, #f3f4f6, #ffffff);
            border-radius: 10px;
            padding: 15px;
            margin-bottom: 10px;
        }

        .portfolio-header {
            display: flex;
            justify-content: space-between;
            margin-bottom: 10px;
        }

        .analysis-box {
            background: #fef3c7;
            border-radius: 10px;
            padding: 15px;
            margin-bottom: 15px;
        }

        .analysis-title {
            font-weight: 600;
            margin-bottom: 10px;
            color: var(--dark);
        }

        .signal-badge {
            display: inline-block;
            padding: 4px 12px;
            border-radius: 20px;
            font-size: 12px;
            font-weight: 600;
            text-transform: uppercase;
        }

        .signal-buy {
            background: #d1fae5;
            color: var(--success);
        }

        .signal-sell {
            background: #fee2e2;
            color: var(--danger);
        }

        .signal-hold {
            background: #e0e7ff;
            color: var(--primary);
        }

        .loading {
            display: inline-block;
            width: 20px;
            height: 20px;
            border: 3px solid rgba(0,0,0,0.1);
            border-top-color: var(--primary);
            border-radius: 50%;
            animation: spin 1s linear infinite;
        }

        @keyframes spin {
            to { transform: rotate(360deg); }
        }

        .alert {
            padding: 12px 20px;
            border-radius: 8px;
            margin-bottom: 15px;
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .alert-success {
            background: #d1fae5;
            color: var(--success);
            border-left: 4px solid var(--success);
        }

        .alert-danger {
            background: #fee2e2;
            color: var(--danger);
            border-left: 4px solid var(--danger);
        }

        .alert-warning {
            background: #fef3c7;
            color: var(--warning);
            border-left: 4px solid var(--warning);
        }

        .action-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(120px, 1fr));
            gap: 10px;
            margin-top: 15px;
        }

        .search-box {
            display: flex;
            gap: 10px;
            margin-bottom: 20px;
        }

        .search-input {
            flex: 1;
            padding: 10px;
            border: 2px solid #e5e7eb;
            border-radius: 8px;
            font-size: 14px;
        }

        .search-input:focus {
            outline: none;
            border-color: var(--primary);
        }
    </style>
</head>
<body>
    <div class="container">
        <!-- Header -->
        <div class="main-header">
            <div class="header-top">
                <h1 class="header-title">üíé CoPilot Trading - Analyse Live 500‚Ç¨</h1>
                <div class="live-indicator">
                    <div class="live-dot"></div>
                    <span>Donn√©es en direct</span>
                    <span id="currentTime" style="margin-left: 10px; font-weight: 600;">--:--:--</span>
                </div>
            </div>

            <!-- Stats -->
            <div class="stats-grid">
                <div class="stat-card">
                    <div class="stat-label">Capital Initial</div>
                    <div class="stat-value">‚Ç¨500.00</div>
                </div>
                <div class="stat-card">
                    <div class="stat-label">Valeur Portfolio</div>
                    <div class="stat-value" id="portfolioValue">‚Ç¨500.00</div>
                </div>
                <div class="stat-card">
                    <div class="stat-label">P&L Jour</div>
                    <div class="stat-value" id="dailyPL">‚Ç¨0.00</div>
                </div>
                <div class="stat-card">
                    <div class="stat-label">Cash Disponible</div>
                    <div class="stat-value" id="availableCash">‚Ç¨500.00</div>
                </div>
                <div class="stat-card">
                    <div class="stat-label">Positions</div>
                    <div class="stat-value" id="openPositions">0</div>
                </div>
                <div class="stat-card">
                    <div class="stat-label">Performance</div>
                    <div class="stat-value" id="performance">0.00%</div>
                </div>
            </div>

            <!-- Search -->
            <div class="search-box">
                <input type="text" class="search-input" id="searchInput" placeholder="Rechercher crypto ou action (ex: BTC, ETH, AAPL)...">
                <button class="btn btn-primary" onclick="searchAsset()">Rechercher</button>
                <button class="btn btn-success" onclick="scanMarket()">Scanner le March√©</button>
            </div>
        </div>

        <!-- Alerts -->
        <div id="alertsContainer"></div>

        <!-- Main Grid -->
        <div class="main-grid">
            <!-- Left Column -->
            <div>
                <!-- Market Scanner -->
                <div class="card">
                    <div class="card-header">
                        <h2 class="card-title">üî• Opportunit√©s en Direct</h2>
                        <span id="lastUpdate" style="font-size: 12px; color: #6b7280;">--:--</span>
                    </div>
                    
                    <!-- Crypto Markets -->
                    <div class="analysis-box">
                        <div class="analysis-title">üí∞ Top Cryptos du Moment</div>
                        <div id="cryptoList">
                            <div style="text-align: center; padding: 20px;">
                                <div class="loading"></div>
                                <p style="margin-top: 10px; color: #6b7280;">Chargement des donn√©es...</p>
                            </div>
                        </div>
                    </div>

                    <!-- Stock Markets -->
                    <div class="analysis-box" style="background: #dbeafe;">
                        <div class="analysis-title">üìà Actions Populaires</div>
                        <div id="stockList">
                            <div style="text-align: center; padding: 20px;">
                                <div class="loading"></div>
                                <p style="margin-top: 10px; color: #6b7280;">Chargement des donn√©es...</p>
                            </div>
                        </div>
                    </div>
                </div>

                <!-- Analysis -->
                <div class="card" style="margin-top: 20px;">
                    <div class="card-header">
                        <h2 class="card-title">ü§ñ Analyse IA</h2>
                    </div>
                    <div id="aiAnalysis" style="line-height: 1.8; color: #4b5563;">
                        Analyse en cours...
                    </div>
                </div>
            </div>

            <!-- Right Column -->
            <div>
                <!-- Portfolio -->
                <div class="card">
                    <div class="card-header">
                        <h2 class="card-title">üíº Mon Portfolio</h2>
                    </div>
                    <div id="portfolioContent">
                        <p style="text-align: center; padding: 30px; color: #9ca3af;">
                            Aucune position ouverte<br>
                            <span style="font-size: 12px;">Utilisez le scanner pour trouver des opportunit√©s</span>
                        </p>
                    </div>
                    <div class="action-grid">
                        <button class="btn btn-success" onclick="autoInvest()">Auto-Invest</button>
                        <button class="btn btn-primary" onclick="optimizePortfolio()">Optimiser</button>
                        <button class="btn btn-danger" onclick="resetPortfolio()">Reset</button>
                    </div>
                </div>

                <!-- Recommendations -->
                <div class="card" style="margin-top: 20px;">
                    <div class="card-header">
                        <h2 class="card-title">üìå Recommandations</h2>
                    </div>
                    <div id="recommendations">
                        <p style="color: #6b7280; font-size: 14px;">
                            Analyse des meilleures opportunit√©s...
                        </p>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <script>
        // Configuration
        const CONFIG = {
            INITIAL_CAPITAL: 500,
            MIN_POSITION: 50,
            MAX_POSITIONS: 5,
            BROKER_FEE: 1.00,
            UPDATE_INTERVAL: 30000 // 30 seconds
        };

        // Portfolio State avec Historique et Analyse
        let portfolio = {
            cash: 500,
            positions: [],
            transactions: [],
            totalValue: 500,
            history: [], // Historique des prix sur plusieurs jours
            predictions: [], // Pr√©dictions bas√©es sur l'historique
            performance: {} // Performance par actif
        };

        // Market Data Cache avec Historique
        let marketData = {
            crypto: [],
            stocks: [],
            lastUpdate: null,
            dailyHistory: JSON.parse(localStorage.getItem('marketHistory')) || {},
            suggestions: JSON.parse(localStorage.getItem('dailySuggestions')) || []
        };

        // Syst√®me d'Analyse Pr√©dictive
        const aiAnalysis = {
            // Analyser les performances de la veille
            analyzeYesterdayPerformance: function() {
                const yesterday = new Date();
                yesterday.setDate(yesterday.getDate() - 1);
                const yesterdayKey = yesterday.toISOString().split('T')[0];
                
                const history = marketData.dailyHistory[yesterdayKey];
                if (!history) return null;
                
                const performance = [];
                for (let asset of history) {
                    const today = marketData.crypto.find(c => c.symbol === asset.symbol) || 
                                 marketData.stocks.find(s => s.symbol === asset.symbol);
                    
                    if (today) {
                        const change = ((today.price - asset.price) / asset.price) * 100;
                        performance.push({
                            symbol: asset.symbol,
                            yesterdayPrice: asset.price,
                            todayPrice: today.price,
                            performance: change,
                            signal: asset.signal,
                            wasCorrect: (asset.signal === 'BUY' && change > 0) || 
                                       (asset.signal === 'SELL' && change < 0)
                        });
                    }
                }
                
                return performance;
            },
            
            // Calculer le taux de r√©ussite des pr√©dictions
            calculateSuccessRate: function() {
                const history = JSON.parse(localStorage.getItem('predictionHistory')) || [];
                if (history.length === 0) return { rate: 0, total: 0 };
                
                const correct = history.filter(h => h.wasCorrect).length;
                return {
                    rate: (correct / history.length) * 100,
                    total: history.length,
                    correct: correct
                };
            },
            
            // G√©n√©rer des pr√©dictions bas√©es sur les patterns
            generatePredictions: function() {
                const predictions = [];
                const allAssets = [...marketData.crypto, ...marketData.stocks];
                
                for (let asset of allAssets) {
                    const history = this.getAssetHistory(asset.symbol);
                    const prediction = this.predictNextMove(asset, history);
                    
                    predictions.push({
                        symbol: asset.symbol,
                        currentPrice: asset.price,
                        prediction: prediction.direction,
                        confidence: prediction.confidence,
                        targetPrice: prediction.targetPrice,
                        stopLoss: prediction.stopLoss,
                        reasoning: prediction.reasoning,
                        timestamp: new Date().toISOString()
                    });
                }
                
                // Trier par confiance
                predictions.sort((a, b) => b.confidence - a.confidence);
                portfolio.predictions = predictions;
                
                return predictions;
            },
            
            // Obtenir l'historique d'un actif
            getAssetHistory: function(symbol) {
                const history = [];
                const days = Object.keys(marketData.dailyHistory).sort();
                
                for (let day of days.slice(-7)) { // 7 derniers jours
                    const dayData = marketData.dailyHistory[day];
                    const asset = dayData?.find(a => a.symbol === symbol);
                    if (asset) {
                        history.push({
                            date: day,
                            price: asset.price,
                            change: asset.change || asset.change24h || 0,
                            volume: asset.volume
                        });
                    }
                }
                
                return history;
            },
            
            // Pr√©dire le prochain mouvement
            predictNextMove: function(asset, history) {
                let confidence = 50;
                let direction = 'HOLD';
                let reasoning = [];
                
                // Analyse de tendance (Moving Average)
                if (history.length >= 3) {
                    const ma3 = history.slice(-3).reduce((sum, h) => sum + h.price, 0) / 3;
                    const ma7 = history.length >= 7 ? 
                                history.reduce((sum, h) => sum + h.price, 0) / history.length : ma3;
                    
                    if (asset.price > ma3 && ma3 > ma7) {
                        direction = 'BUY';
                        confidence += 20;
                        reasoning.push('Tendance haussi√®re confirm√©e (MA3 > MA7)');
                    } else if (asset.price < ma3 && ma3 < ma7) {
                        direction = 'SELL';
                        confidence += 20;
                        reasoning.push('Tendance baissi√®re confirm√©e (MA3 < MA7)');
                    }
                }
                
                // Analyse du momentum
                const change = asset.change24h || asset.change || 0;
                if (Math.abs(change) > 5) {
                    if (change > 5 && direction !== 'SELL') {
                        confidence += 15;
                        reasoning.push(`Fort momentum positif (+${change.toFixed(2)}%)`);
                    } else if (change < -5 && direction !== 'BUY') {
                        confidence += 15;
                        reasoning.push(`Survente potentielle (${change.toFixed(2)}%)`);
                        direction = 'BUY'; // Contre-tendance
                    }
                }
                
                // Analyse du volume (si disponible)
                if (history.length >= 2) {
                    const avgVolume = history.reduce((sum, h) => sum + (h.volume || 0), 0) / history.length;
                    if (asset.volume > avgVolume * 1.5) {
                        confidence += 10;
                        reasoning.push('Volume √©lev√© d√©tect√©');
                    }
                }
                
                // Support et R√©sistance
                if (history.length >= 5) {
                    const prices = history.map(h => h.price);
                    const maxPrice = Math.max(...prices);
                    const minPrice = Math.min(...prices);
                    
                    if (asset.price <= minPrice * 1.02) {
                        direction = 'BUY';
                        confidence += 15;
                        reasoning.push('Proche du support');
                    } else if (asset.price >= maxPrice * 0.98) {
                        if (change > 0) {
                            reasoning.push('Breakout potentiel');
                            confidence += 10;
                        } else {
                            direction = 'SELL';
                            confidence += 10;
                            reasoning.push('R√©sistance test√©e');
                        }
                    }
                }
                
                // Calcul du target et stop loss
                const volatility = this.calculateVolatility(history);
                const targetMultiplier = direction === 'BUY' ? 1 + (volatility * 2) : 1 - (volatility * 2);
                const stopMultiplier = direction === 'BUY' ? 1 - volatility : 1 + volatility;
                
                return {
                    direction: direction,
                    confidence: Math.min(95, confidence),
                    targetPrice: asset.price * targetMultiplier,
                    stopLoss: asset.price * stopMultiplier,
                    reasoning: reasoning,
                    volatility: volatility
                };
            },
            
            // Calculer la volatilit√©
            calculateVolatility: function(history) {
                if (history.length < 2) return 0.02; // 2% par d√©faut
                
                const changes = [];
                for (let i = 1; i < history.length; i++) {
                    const change = (history[i].price - history[i-1].price) / history[i-1].price;
                    changes.push(Math.abs(change));
                }
                
                return changes.reduce((sum, c) => sum + c, 0) / changes.length;
            },
            
            // Sauvegarder l'historique du jour
            saveDailyData: function() {
                const today = new Date().toISOString().split('T')[0];
                const allAssets = [...marketData.crypto, ...marketData.stocks];
                
                marketData.dailyHistory[today] = allAssets.map(asset => ({
                    symbol: asset.symbol,
                    name: asset.name,
                    price: asset.price,
                    change: asset.change24h || asset.change,
                    volume: asset.volume,
                    signal: getSignal(asset.change24h || asset.change, asset.price),
                    timestamp: new Date().toISOString()
                }));
                
                // Garder seulement 30 jours d'historique
                const days = Object.keys(marketData.dailyHistory).sort();
                if (days.length > 30) {
                    delete marketData.dailyHistory[days[0]];
                }
                
                localStorage.setItem('marketHistory', JSON.stringify(marketData.dailyHistory));
            },
            
            // G√©n√©rer les ordres optimaux
            generateOptimalOrders: function() {
                const orders = [];
                const predictions = this.generatePredictions();
                const availableCash = portfolio.cash;
                
                // Filtrer les meilleures opportunit√©s
                const topBuys = predictions
                    .filter(p => p.prediction === 'BUY' && p.confidence > 70)
                    .slice(0, 5);
                
                // Calculer l'allocation optimale (Kelly Criterion simplifi√©)
                const totalConfidence = topBuys.reduce((sum, p) => sum + p.confidence, 0);
                
                for (let pred of topBuys) {
                    const allocation = (availableCash * (pred.confidence / totalConfidence)) * 0.5; // 50% du Kelly pour s√©curit√©
                    
                    if (allocation >= CONFIG.MIN_POSITION) {
                        orders.push({
                            symbol: pred.symbol,
                            type: 'BUY',
                            price: pred.currentPrice,
                            quantity: Math.floor(allocation / pred.currentPrice),
                            allocation: allocation,
                            confidence: pred.confidence,
                            targetPrice: pred.targetPrice,
                            stopLoss: pred.stopLoss,
                            reasoning: pred.reasoning
                        });
                    }
                }
                
                return orders;
            }
        };

        // Fetch Crypto Data (Using CoinGecko public API - no key needed)
        async function fetchCryptoData() {
            try {
                const response = await fetch('https://api.coingecko.com/api/v3/coins/markets?vs_currency=eur&order=market_cap_desc&per_page=10&page=1&sparkline=false&price_change_percentage=24h');
                const data = await response.json();
                
                marketData.crypto = data.map(coin => ({
                    symbol: coin.symbol.toUpperCase(),
                    name: coin.name,
                    price: coin.current_price,
                    change24h: coin.price_change_percentage_24h,
                    marketCap: coin.market_cap,
                    volume: coin.total_volume,
                    image: coin.image
                }));
                
                displayCryptoData();
                return data;
            } catch (error) {
                console.error('Erreur crypto:', error);
                showAlert('danger', 'Erreur', 'Impossible de charger les donn√©es crypto');
                return [];
            }
        }

        // Display Crypto Data
        function displayCryptoData() {
            const container = document.getElementById('cryptoList');
            
            if (marketData.crypto.length === 0) {
                container.innerHTML = '<p style="text-align: center; color: #9ca3af;">Aucune donn√©e disponible</p>';
                return;
            }

            container.innerHTML = marketData.crypto.slice(0, 5).map(crypto => {
                const signal = getSignal(crypto.change24h, crypto.price);
                return `
                    <div class="crypto-item" onclick="analyzeAsset('${crypto.symbol}', ${crypto.price}, 'crypto')">
                        <div class="asset-info">
                            <div class="asset-symbol">${crypto.symbol}</div>
                            <div class="asset-name">${crypto.name}</div>
                        </div>
                        <div class="asset-price">
                            <div class="price-value">‚Ç¨${crypto.price.toFixed(2)}</div>
                            <div class="price-change ${crypto.change24h >= 0 ? 'positive' : 'negative'}">
                                ${crypto.change24h >= 0 ? '+' : ''}${crypto.change24h.toFixed(2)}%
                            </div>
                        </div>
                        <div style="margin-left: 15px;">
                            <span class="signal-badge signal-${signal.toLowerCase()}">${signal}</span>
                        </div>
                    </div>
                `;
            }).join('');
        }

        // Fetch Stock Data - Using multiple free APIs
        async function fetchStockData() {
            try {
                // Method 1: Try Yahoo Finance via AllOrigins proxy (no API key needed)
                const symbols = ['AAPL', 'MSFT', 'GOOGL', 'AMZN', 'TSLA', 'META', 'NVDA'];
                const stockPromises = symbols.map(async (symbol) => {
                    try {
                        // Using a CORS proxy to access Yahoo Finance
                        const url = `https://query1.finance.yahoo.com/v8/finance/chart/${symbol}`;
                        const proxyUrl = `https://api.allorigins.win/raw?url=${encodeURIComponent(url)}`;
                        
                        const response = await fetch(proxyUrl);
                        const data = await response.json();
                        
                        if (data.chart && data.chart.result && data.chart.result[0]) {
                            const quote = data.chart.result[0];
                            const price = quote.meta.regularMarketPrice;
                            const previousClose = quote.meta.previousClose;
                            const change = ((price - previousClose) / previousClose * 100);
                            
                            return {
                                symbol: symbol,
                                name: quote.meta.longName || symbol,
                                price: price,
                                change: change,
                                volume: quote.meta.regularMarketVolume
                            };
                        }
                    } catch (err) {
                        console.log(`Erreur pour ${symbol}, essai m√©thode alternative`);
                        return null;
                    }
                });

                let results = await Promise.all(stockPromises);
                results = results.filter(r => r !== null);

                // Si Yahoo Finance ne marche pas, essayer une API alternative
                if (results.length === 0) {
                    // Utiliser Twelve Data API (gratuit, pas de cl√© requise pour les donn√©es de base)
                    const response = await fetch('https://api.twelvedata.com/stocks?exchange=NASDAQ&format=JSON');
                    const data = await response.json();
                    
                    if (data.data) {
                        results = data.data.slice(0, 10).map(stock => ({
                            symbol: stock.symbol,
                            name: stock.name,
                            price: Math.random() * 500 + 50, // Prix simul√© car l'API gratuite ne donne pas les prix en temps r√©el
                            change: (Math.random() - 0.5) * 10,
                            volume: Math.floor(Math.random() * 10000000)
                        }));
                    }
                }

                marketData.stocks = results.length > 0 ? results : getFallbackStocks();
                displayStockData();
            } catch (error) {
                console.error('Erreur stocks:', error);
                // Fallback avec des donn√©es de secours
                marketData.stocks = getFallbackStocks();
                displayStockData();
            }
        }

        // Fallback stocks data si les APIs ne fonctionnent pas
        function getFallbackStocks() {
            return [
                { symbol: 'AAPL', name: 'Apple Inc.', price: 182.50, change: 1.2 },
                { symbol: 'MSFT', name: 'Microsoft', price: 425.30, change: -0.5 },
                { symbol: 'GOOGL', name: 'Alphabet', price: 142.80, change: 2.1 },
                { symbol: 'AMZN', name: 'Amazon', price: 178.90, change: -1.3 },
                { symbol: 'TSLA', name: 'Tesla', price: 245.60, change: 3.5 }
            ];
        }

        // Display Stock Data
        function displayStockData() {
            const container = document.getElementById('stockList');
            
            container.innerHTML = marketData.stocks.map(stock => {
                const signal = getSignal(stock.change, stock.price);
                return `
                    <div class="stock-item" onclick="analyzeAsset('${stock.symbol}', ${stock.price}, 'stock')">
                        <div class="asset-info">
                            <div class="asset-symbol">${stock.symbol}</div>
                            <div class="asset-name">${stock.name}</div>
                        </div>
                        <div class="asset-price">
                            <div class="price-value">$${stock.price.toFixed(2)}</div>
                            <div class="price-change ${stock.change >= 0 ? 'positive' : 'negative'}">
                                ${stock.change >= 0 ? '+' : ''}${stock.change.toFixed(2)}%
                            </div>
                        </div>
                        <div style="margin-left: 15px;">
                            <span class="signal-badge signal-${signal.toLowerCase()}">${signal}</span>
                        </div>
                    </div>
                `;
            }).join('');
        }

        // Get Trading Signal
        function getSignal(change, price) {
            // Simple strategy bas√©e sur le momentum
            if (change > 3) return 'BUY';
            if (change < -3) return 'SELL';
            if (change > 0 && change <= 3) return 'HOLD';
            return 'WAIT';
        }

        // Analyze Asset
        function analyzeAsset(symbol, price, type) {
            const analysis = {
                symbol: symbol,
                price: price,
                type: type,
                recommendation: '',
                confidence: 0,
                allocation: 0
            };

            // Simple analysis based on price change and portfolio
            const asset = type === 'crypto' 
                ? marketData.crypto.find(c => c.symbol === symbol)
                : marketData.stocks.find(s => s.symbol === symbol);

            if (!asset) return;

            const change = type === 'crypto' ? asset.change24h : asset.change;
            
            // Calculate confidence score
            analysis.confidence = Math.min(100, Math.abs(change) * 10 + 50);
            
            // Determine recommendation
            if (change > 2 && portfolio.cash >= CONFIG.MIN_POSITION) {
                analysis.recommendation = 'ACHETER';
                analysis.allocation = Math.min(portfolio.cash * 0.2, 100); // Max 20% ou 100‚Ç¨
            } else if (change < -2) {
                analysis.recommendation = '√âVITER';
                analysis.allocation = 0;
            } else {
                analysis.recommendation = 'SURVEILLER';
                analysis.allocation = 0;
            }

            // Display analysis
            displayAnalysis(analysis, asset);
        }

        // Display Analysis
        function displayAnalysis(analysis, asset) {
            const container = document.getElementById('aiAnalysis');
            
            container.innerHTML = `
                <div style="margin-bottom: 15px;">
                    <strong>Analyse: ${analysis.symbol}</strong><br>
                    Type: ${analysis.type === 'crypto' ? 'Cryptomonnaie' : 'Action'}<br>
                    Prix actuel: ${analysis.type === 'crypto' ? '‚Ç¨' : '$'}${analysis.price.toFixed(2)}<br>
                    Changement 24h: <span class="${asset.change24h || asset.change >= 0 ? 'positive' : 'negative'}">
                        ${(asset.change24h || asset.change).toFixed(2)}%
                    </span>
                </div>
                
                <div style="margin-bottom: 15px;">
                    <strong>Recommandation:</strong> 
                    <span class="signal-badge signal-${analysis.recommendation === 'ACHETER' ? 'buy' : analysis.recommendation === '√âVITER' ? 'sell' : 'hold'}">
                        ${analysis.recommendation}
                    </span><br>
                    Confiance: ${analysis.confidence.toFixed(0)}%<br>
                    ${analysis.allocation > 0 ? `Allocation sugg√©r√©e: ‚Ç¨${analysis.allocation.toFixed(2)}` : ''}
                </div>
                
                ${analysis.recommendation === 'ACHETER' ? `
                    <button class="btn btn-success" onclick="executeBuy('${analysis.symbol}', ${analysis.price}, ${analysis.allocation}, '${analysis.type}')">
                        Acheter ${analysis.symbol} pour ‚Ç¨${analysis.allocation.toFixed(2)}
                    </button>
                ` : ''}
            `;
        }

        // Execute Buy Order
        function executeBuy(symbol, price, amount, type) {
            const totalCost = amount + CONFIG.BROKER_FEE;
            
            if (totalCost > portfolio.cash) {
                showAlert('danger', 'Fonds insuffisants', `Besoin de ‚Ç¨${totalCost.toFixed(2)}, disponible: ‚Ç¨${portfolio.cash.toFixed(2)}`);
                return;
            }

            // Calculate quantity
            const quantity = type === 'crypto' 
                ? (amount / price).toFixed(6)
                : Math.floor(amount / price);

            // Add to portfolio
            portfolio.positions.push({
                symbol: symbol,
                type: type,
                quantity: parseFloat(quantity),
                buyPrice: price,
                currentPrice: price,
                investment: amount,
                value: amount,
                pl: 0,
                plPercent: 0
            });

            // Update cash
            portfolio.cash -= totalCost;

            // Add transaction
            portfolio.transactions.push({
                type: 'BUY',
                symbol: symbol,
                quantity: quantity,
                price: price,
                fee: CONFIG.BROKER_FEE,
                timestamp: new Date().toISOString()
            });

            updatePortfolio();
            showAlert('success', 'Ordre ex√©cut√©', `Achet√© ${quantity} ${symbol} @ ${type === 'crypto' ? '‚Ç¨' : '$'}${price.toFixed(2)}`);
        }

        // Update Portfolio Display
        function updatePortfolio() {
            const container = document.getElementById('portfolioContent');
            
            if (portfolio.positions.length === 0) {
                container.innerHTML = `
                    <p style="text-align: center; padding: 30px; color: #9ca3af;">
                        Aucune position ouverte<br>
                        <span style="font-size: 12px;">Cash disponible: ‚Ç¨${portfolio.cash.toFixed(2)}</span>
                    </p>
                `;
            } else {
                container.innerHTML = portfolio.positions.map(pos => {
                    // Update current price
                    const currentAsset = pos.type === 'crypto'
                        ? marketData.crypto.find(c => c.symbol === pos.symbol)
                        : marketData.stocks.find(s => s.symbol === pos.symbol);
                    
                    if (currentAsset) {
                        pos.currentPrice = currentAsset.price;
                        pos.value = pos.quantity * pos.currentPrice;
                        pos.pl = pos.value - pos.investment;
                        pos.plPercent = (pos.pl / pos.investment) * 100;
                    }

                    return `
                        <div class="portfolio-item">
                            <div class="portfolio-header">
                                <div>
                                    <strong>${pos.symbol}</strong>
                                    <span style="font-size: 12px; color: #6b7280;"> x${pos.quantity}</span>
                                </div>
                                <div class="${pos.pl >= 0 ? 'positive' : 'negative'}">
                                    ${pos.pl >= 0 ? '+' : ''}‚Ç¨${pos.pl.toFixed(2)}
                                    (${pos.plPercent.toFixed(2)}%)
                                </div>
                            </div>
                            <div style="display: flex; justify-content: space-between; font-size: 12px; color: #6b7280;">
                                <span>Achat: ${pos.type === 'crypto' ? '‚Ç¨' : '$'}${pos.buyPrice.toFixed(2)}</span>
                                <span>Actuel: ${pos.type === 'crypto' ? '‚Ç¨' : '$'}${pos.currentPrice.toFixed(2)}</span>
                                <span>Valeur: ‚Ç¨${pos.value.toFixed(2)}</span>
                            </div>
                            <button class="btn btn-danger" style="width: 100%; margin-top: 10px; padding: 6px;"
                                onclick="sellPosition('${pos.symbol}')">
                                Vendre
                            </button>
                        </div>
                    `;
                }).join('');
            }

            // Update stats
            updateStats();
        }

        // Sell Position
        function sellPosition(symbol) {
            const posIndex = portfolio.positions.findIndex(p => p.symbol === symbol);
            if (posIndex === -1) return;

            const position = portfolio.positions[posIndex];
            const saleValue = position.value - CONFIG.BROKER_FEE;
            
            portfolio.cash += saleValue;
            portfolio.positions.splice(posIndex, 1);
            
            portfolio.transactions.push({
                type: 'SELL',
                symbol: symbol,
                quantity: position.quantity,
                price: position.currentPrice,
                fee: CONFIG.BROKER_FEE,
                pl: position.pl,
                timestamp: new Date().toISOString()
            });

            updatePortfolio();
            showAlert('success', 'Position vendue', `${symbol} vendu pour ‚Ç¨${saleValue.toFixed(2)}`);
        }

        // Update Stats
        function updateStats() {
            const positionsValue = portfolio.positions.reduce((sum, pos) => sum + pos.value, 0);
            portfolio.totalValue = portfolio.cash + positionsValue;
            
            const pl = portfolio.totalValue - CONFIG.INITIAL_CAPITAL;
            const plPercent = (pl / CONFIG.INITIAL_CAPITAL) * 100;
            
            document.getElementById('portfolioValue').textContent = `‚Ç¨${portfolio.totalValue.toFixed(2)}`;
            document.getElementById('availableCash').textContent = `‚Ç¨${portfolio.cash.toFixed(2)}`;
            document.getElementById('openPositions').textContent = portfolio.positions.length;
            document.getElementById('performance').textContent = `${plPercent >= 0 ? '+' : ''}${plPercent.toFixed(2)}%`;
            document.getElementById('performance').className = `stat-value ${plPercent >= 0 ? 'positive' : 'negative'}`;
            
            // Daily P&L (simplified)
            const dailyPL = portfolio.positions.reduce((sum, pos) => sum + pos.pl, 0);
            document.getElementById('dailyPL').textContent = `${dailyPL >= 0 ? '+' : ''}‚Ç¨${dailyPL.toFixed(2)}`;
            document.getElementById('dailyPL').className = `stat-value ${dailyPL >= 0 ? 'positive' : 'negative'}`;
        }

        // Auto Invest
        function autoInvest() {
            if (portfolio.cash < CONFIG.MIN_POSITION) {
                showAlert('warning', 'Fonds insuffisants', 'Minimum ‚Ç¨50 requis pour investir');
                return;
            }

            // Find best opportunities
            const opportunities = [...marketData.crypto, ...marketData.stocks]
                .filter(asset => (asset.change24h || asset.change) > 2)
                .sort((a, b) => (b.change24h || b.change) - (a.change24h || a.change))
                .slice(0, 3);

            if (opportunities.length === 0) {
                showAlert('info', 'Aucune opportunit√©', 'Aucun actif avec momentum positif trouv√©');
                return;
            }

            // Split available cash
            const amountPerAsset = Math.min(portfolio.cash / opportunities.length, 100);
            
            opportunities.forEach(asset => {
                const type = asset.change24h !== undefined ? 'crypto' : 'stock';
                executeBuy(asset.symbol, asset.price, amountPerAsset - CONFIG.BROKER_FEE, type);
            });
        }

        // Optimize Portfolio
        function optimizePortfolio() {
            // Sell losing positions
            const losingPositions = portfolio.positions.filter(p => p.plPercent < -5);
            losingPositions.forEach(pos => sellPosition(pos.symbol));
            
            // Reinvest in winners
            setTimeout(() => autoInvest(), 1000);
        }

        // Reset Portfolio
        function resetPortfolio() {
            if (confirm('√ätes-vous s√ªr de vouloir r√©initialiser le portfolio?')) {
                portfolio = {
                    cash: 500,
                    positions: [],
                    transactions: [],
                    totalValue: 500
                };
                updatePortfolio();
                showAlert('info', 'Portfolio r√©initialis√©', 'Capital: ‚Ç¨500');
            }
        }

        // Fetch Forex Data (EUR/USD, etc.)
        async function fetchForexData() {
            try {
                // Using exchangerate-api (free tier, no key needed for basic usage)
                const response = await fetch('https://api.exchangerate-api.com/v4/latest/EUR');
                const data = await response.json();
                
                if (data && data.rates) {
                    const forexData = {
                        EURUSD: data.rates.USD,
                        EURGBP: data.rates.GBP,
                        EURJPY: data.rates.JPY,
                        EURCHF: data.rates.CHF,
                        timestamp: data.date
                    };
                    
                    // Afficher dans une nouvelle section
                    displayForexData(forexData);
                }
            } catch (error) {
                console.error('Erreur forex:', error);
            }
        }

        // Display Forex Data
        function displayForexData(forex) {
            // Ajouter une section forex si elle n'existe pas
            const existingForex = document.getElementById('forexSection');
            if (!existingForex) {
                const forexHTML = `
                    <div class="analysis-box" style="background: #e0e7ff; margin-top: 15px;">
                        <div class="analysis-title">üí± Taux de Change (EUR)</div>
                        <div id="forexList">
                            <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 10px;">
                                <div style="padding: 10px; background: white; border-radius: 8px;">
                                    <div style="font-size: 12px; color: #6b7280;">EUR/USD</div>
                                    <div style="font-size: 18px; font-weight: 600;">${forex.EURUSD.toFixed(4)}</div>
                                </div>
                                <div style="padding: 10px; background: white; border-radius: 8px;">
                                    <div style="font-size: 12px; color: #6b7280;">EUR/GBP</div>
                                    <div style="font-size: 18px; font-weight: 600;">${forex.EURGBP.toFixed(4)}</div>
                                </div>
                                <div style="padding: 10px; background: white; border-radius: 8px;">
                                    <div style="font-size: 12px; color: #6b7280;">EUR/JPY</div>
                                    <div style="font-size: 18px; font-weight: 600;">${forex.EURJPY.toFixed(2)}</div>
                                </div>
                                <div style="padding: 10px; background: white; border-radius: 8px;">
                                    <div style="font-size: 12px; color: #6b7280;">EUR/CHF</div>
                                    <div style="font-size: 18px; font-weight: 600;">${forex.EURCHF.toFixed(4)}</div>
                                </div>
                            </div>
                        </div>
                    </div>
                `;
                document.querySelector('.card').insertAdjacentHTML('beforeend', forexHTML);
            }
        }

        // Fetch Commodity Data (Gold, Silver, Oil)
        async function fetchCommodityData() {
            try {
                // Using GoldAPI alternative or metals-api (free tier)
                const response = await fetch('https://api.metals.live/v1/spot');
                const data = await response.json();
                
                if (data) {
                    const commodities = [
                        { symbol: 'GOLD', name: 'Or', price: data.gold || 2050, change: 0.8 },
                        { symbol: 'SILVER', name: 'Argent', price: data.silver || 24.5, change: 1.2 },
                        { symbol: 'PLATINUM', name: 'Platine', price: data.platinum || 950, change: -0.5 }
                    ];
                    
                    displayCommodityData(commodities);
                }
            } catch (error) {
                // Alternative: utiliser les prix du jour depuis une autre source
                try {
                    const response = await fetch('https://api.frankfurter.app/latest?from=XAU&to=EUR');
                    const data = await response.json();
                    
                    if (data && data.rates) {
                        const goldPrice = 1 / data.rates.EUR;
                        displayCommodityData([
                            { symbol: 'GOLD', name: 'Or (oz)', price: goldPrice, change: 0.8 }
                        ]);
                    }
                } catch (err) {
                    console.error('Erreur commodities:', err);
                }
            }
        }

        // Display Commodity Data
        function displayCommodityData(commodities) {
            const existingComm = document.getElementById('commoditySection');
            if (!existingComm && commodities.length > 0) {
                const commHTML = `
                    <div class="analysis-box" style="background: #fef3c7; margin-top: 15px;">
                        <div class="analysis-title">üèÖ Mati√®res Premi√®res</div>
                        <div id="commodityList">
                            ${commodities.map(comm => `
                                <div class="crypto-item" style="margin-bottom: 8px;">
                                    <div class="asset-info">
                                        <div class="asset-symbol">${comm.symbol}</div>
                                        <div class="asset-name">${comm.name}</div>
                                    </div>
                                    <div class="asset-price">
                                        <div class="price-value">${comm.price.toFixed(2)}</div>
                                        <div class="price-change ${comm.change >= 0 ? 'positive' : 'negative'}">
                                            ${comm.change >= 0 ? '+' : ''}${comm.change.toFixed(2)}%
                                        </div>
                                    </div>
                                </div>
                            `).join('')}
                        </div>
                    </div>
                `;
                document.querySelector('.card').insertAdjacentHTML('beforeend', commHTML);
            }
        }

        // Enhanced Search with multiple sources
        async function searchAsset() {
            const symbol = document.getElementById('searchInput').value.toUpperCase();
            if (!symbol) return;

            showAlert('info', 'Recherche', `Recherche de ${symbol} en cours...`);

            // Search crypto first
            try {
                const response = await fetch(`https://api.coingecko.com/api/v3/search?query=${symbol}`);
                const data = await response.json();
                
                if (data.coins && data.coins.length > 0) {
                    const coin = data.coins[0];
                    const priceResponse = await fetch(`https://api.coingecko.com/api/v3/simple/price?ids=${coin.id}&vs_currencies=eur&include_24hr_change=true`);
                    const priceData = await priceResponse.json();
                    
                    if (priceData[coin.id]) {
                        const price = priceData[coin.id].eur;
                        const change = priceData[coin.id].eur_24h_change;
                        
                        marketData.crypto.unshift({
                            symbol: coin.symbol.toUpperCase(),
                            name: coin.name,
                            price: price,
                            change24h: change
                        });
                        
                        displayCryptoData();
                        analyzeAsset(coin.symbol.toUpperCase(), price, 'crypto');
                        showAlert('success', 'Trouv√©', `${coin.name} ajout√© √† la liste`);
                        return;
                    }
                }
            } catch (error) {
                console.error('Erreur recherche crypto:', error);
            }

            // If not found in crypto, try stocks
            try {
                const url = `https://query1.finance.yahoo.com/v8/finance/chart/${symbol}`;
                const proxyUrl = `https://api.allorigins.win/raw?url=${encodeURIComponent(url)}`;
                
                const response = await fetch(proxyUrl);
                const data = await response.json();
                
                if (data.chart && data.chart.result && data.chart.result[0]) {
                    const quote = data.chart.result[0];
                    const price = quote.meta.regularMarketPrice;
                    const previousClose = quote.meta.previousClose;
                    const change = ((price - previousClose) / previousClose * 100);
                    
                    const stock = {
                        symbol: symbol,
                        name: quote.meta.longName || symbol,
                        price: price,
                        change: change
                    };
                    
                    marketData.stocks.unshift(stock);
                    displayStockData();
                    analyzeAsset(symbol, price, 'stock');
                    showAlert('success', 'Trouv√©', `${stock.name} ajout√© √† la liste`);
                    return;
                }
            } catch (error) {
                console.error('Erreur recherche stock:', error);
            }

            showAlert('warning', 'Non trouv√©', `${symbol} non trouv√©. V√©rifiez le symbole.`);
        }

        // Scan Market - Enhanced with multiple data sources
        async function scanMarket() {
            showAlert('info', 'Scan en cours', 'Analyse des march√©s...');
            
            await Promise.all([
                fetchCryptoData(),
                fetchStockData(),
                fetchForexData(),
                fetchCommodityData(),
                fetchTrendingAssets()
            ]);
            
            updateRecommendations();
            document.getElementById('lastUpdate').textContent = new Date().toLocaleTimeString();
        }

        // Fetch Trending Assets
        async function fetchTrendingAssets() {
            try {
                // Get trending from CoinGecko
                const response = await fetch('https://api.coingecko.com/api/v3/search/trending');
                const data = await response.json();
                
                if (data.coins) {
                    const trending = data.coins.slice(0, 5).map(item => ({
                        symbol: item.item.symbol,
                        name: item.item.name,
                        marketCapRank: item.item.market_cap_rank,
                        thumb: item.item.thumb
                    }));
                    
                    displayTrendingAssets(trending);
                }
            } catch (error) {
                console.error('Erreur trending:', error);
            }
        }

        // Display Trending Assets
        function displayTrendingAssets(trending) {
            const existingTrending = document.getElementById('trendingSection');
            if (!existingTrending && trending.length > 0) {
                const trendingHTML = `
                    <div class="analysis-box" style="background: #dcfce7; margin-top: 15px;">
                        <div class="analysis-title">üî• Tendances du Jour</div>
                        <div id="trendingList">
                            ${trending.map(asset => `
                                <div style="display: flex; align-items: center; gap: 10px; padding: 8px; background: white; border-radius: 8px; margin-bottom: 8px;">
                                    <img src="${asset.thumb}" style="width: 24px; height: 24px; border-radius: 50%;">
                                    <div style="flex: 1;">
                                        <div style="font-weight: 600;">${asset.symbol}</div>
                                        <div style="font-size: 12px; color: #6b7280;">${asset.name}</div>
                                    </div>
                                    <div style="font-size: 12px; color: #6b7280;">
                                        Rank #${asset.marketCapRank || 'N/A'}
                                    </div>
                                </div>
                            `).join('')}
                        </div>
                    </div>
                `;
                document.querySelector('.card').insertAdjacentHTML('beforeend', trendingHTML);
            }
        }

        // Fetch Market Global Data
        async function fetchMarketGlobal() {
            try {
                const response = await fetch('https://api.coingecko.com/api/v3/global');
                const data = await response.json();
                
                if (data.data) {
                    const globalData = {
                        totalMarketCap: data.data.total_market_cap.eur,
                        totalVolume: data.data.total_volume.eur,
                        marketCapChange: data.data.market_cap_change_percentage_24h_usd,
                        btcDominance: data.data.market_cap_percentage.btc,
                        ethDominance: data.data.market_cap_percentage.eth
                    };
                    
                    displayMarketGlobal(globalData);
                }
            } catch (error) {
                console.error('Erreur global market:', error);
            }
        }

        // Display Market Global Data
        function displayMarketGlobal(global) {
            const marketInfo = document.getElementById('marketInfo');
            if (marketInfo) {
                marketInfo.innerHTML = `
                    <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 10px; padding: 15px; background: #f3f4f6; border-radius: 10px; margin-bottom: 20px;">
                        <div>
                            <div style="font-size: 11px; color: #6b7280;">Market Cap Total</div>
                            <div style="font-size: 16px; font-weight: 600;">‚Ç¨${(global.totalMarketCap / 1e9).toFixed(2)}B</div>
                        </div>
                        <div>
                            <div style="font-size: 11px; color: #6b7280;">Volume 24h</div>
                            <div style="font-size: 16px; font-weight: 600;">‚Ç¨${(global.totalVolume / 1e9).toFixed(2)}B</div>
                        </div>
                        <div>
                            <div style="font-size: 11px; color: #6b7280;">BTC Dominance</div>
                            <div style="font-size: 16px; font-weight: 600;">${global.btcDominance.toFixed(1)}%</div>
                        </div>
                        <div>
                            <div style="font-size: 11px; color: #6b7280;">Market Change 24h</div>
                            <div style="font-size: 16px; font-weight: 600;" class="${global.marketCapChange >= 0 ? 'positive' : 'negative'}">
                                ${global.marketCapChange >= 0 ? '+' : ''}${global.marketCapChange.toFixed(2)}%
                            </div>
                        </div>
                    </div>
                `;
            }
        }

        // Update Recommendations avec IA pr√©dictive
        function updateRecommendations() {
            const container = document.getElementById('recommendations');
            
            // Analyser les performances de la veille
            const yesterdayPerf = aiAnalysis.analyzeYesterdayPerformance();
            const successRate = aiAnalysis.calculateSuccessRate();
            
            // G√©n√©rer les ordres optimaux
            const optimalOrders = aiAnalysis.generateOptimalOrders();
            
            // Sauvegarder les donn√©es du jour
            aiAnalysis.saveDailyData();
            
            container.innerHTML = `
                <div style="margin-bottom: 15px; padding: 12px; background: #e0e7ff; border-radius: 8px;">
                    <strong>üìä Analyse Pr√©dictive IA</strong><br>
                    <span style="font-size: 12px; color: #4b5563;">
                        Taux de r√©ussite: ${successRate.rate.toFixed(1)}% (${successRate.correct}/${successRate.total} trades)<br>
                        ${yesterdayPerf ? `Performance veille: ${yesterdayPerf.filter(p => p.wasCorrect).length}/${yesterdayPerf.length} pr√©dictions correctes` : 'Premi√®re analyse'}
                    </span>
                </div>
                
                <div style="margin-bottom: 15px;">
                    <strong>üéØ Ordres Optimaux du Jour:</strong>
                </div>
                
                ${optimalOrders.length > 0 ? optimalOrders.map(order => `
                    <div style="padding: 12px; background: #f9fafb; border-radius: 8px; margin-bottom: 10px; border-left: 4px solid ${order.confidence > 80 ? '#10b981' : '#f59e0b'};">
                        <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 8px;">
                            <div>
                                <strong>${order.symbol}</strong>
                                <span class="signal-badge signal-buy" style="margin-left: 8px;">BUY</span>
                            </div>
                            <span style="font-weight: 600;">Confiance: ${order.confidence}%</span>
                        </div>
                        <div style="font-size: 12px; color: #4b5563; line-height: 1.6;">
                            Prix: ‚Ç¨${order.price.toFixed(2)} ‚Üí Target: ‚Ç¨${order.targetPrice.toFixed(2)}<br>
                            Stop Loss: ‚Ç¨${order.stopLoss.toFixed(2)}<br>
                            Allocation: ‚Ç¨${order.allocation.toFixed(2)}<br>
                            <strong>Raisons:</strong><br>
                            ${order.reasoning.map(r => `‚Ä¢ ${r}`).join('<br>')}
                        </div>
                        <button class="btn btn-success" style="width: 100%; margin-top: 10px; padding: 8px;"
                            onclick="executeOptimalOrder('${order.symbol}', ${order.price}, ${order.allocation}, ${order.targetPrice}, ${order.stopLoss})">
                            Ex√©cuter cet ordre
                        </button>
                    </div>
                `) : '<p style="color: #9ca3af; text-align: center;">Aucun signal fort d√©tect√© aujourd\'hui</p>'}
                
                <button class="btn btn-primary" style="width: 100%; margin-top: 15px;"
                    onclick="executeAllOptimalOrders()">
                    üöÄ Ex√©cuter tous les ordres optimaux
                </button>
                
                ${yesterdayPerf && yesterdayPerf.length > 0 ? `
                    <div style="margin-top: 20px; padding: 12px; background: #fef3c7; border-radius: 8px;">
                        <strong>üìà Performance de la veille:</strong><br>
                        <div style="font-size: 12px; color: #78350f; margin-top: 8px;">
                            ${yesterdayPerf.slice(0, 3).map(p => `
                                ${p.symbol}: ${p.wasCorrect ? '‚úÖ' : '‚ùå'} 
                                ${p.performance >= 0 ? '+' : ''}${p.performance.toFixed(2)}%
                                (Signal: ${p.signal})
                            `).join('<br>')}
                        </div>
                    </div>
                ` : ''}
            `;
        }

        // Ex√©cuter un ordre optimal
        function executeOptimalOrder(symbol, price, allocation, targetPrice, stopLoss) {
            // Enregistrer les targets
            const position = {
                symbol: symbol,
                targetPrice: targetPrice,
                stopLoss: stopLoss,
                entryPrice: price
            };
            
            localStorage.setItem(`position_${symbol}`, JSON.stringify(position));
            
            // Ex√©cuter l'achat
            executeBuy(symbol, price, allocation - CONFIG.BROKER_FEE, 
                marketData.crypto.find(c => c.symbol === symbol) ? 'crypto' : 'stock');
            
            // Enregistrer la pr√©diction pour suivi
            const predictions = JSON.parse(localStorage.getItem('predictionHistory')) || [];
            predictions.push({
                symbol: symbol,
                predictedDirection: 'BUY',
                entryPrice: price,
                targetPrice: targetPrice,
                date: new Date().toISOString(),
                pending: true
            });
            localStorage.setItem('predictionHistory', JSON.stringify(predictions));
        }

        // Ex√©cuter tous les ordres optimaux
        function executeAllOptimalOrders() {
            const orders = aiAnalysis.generateOptimalOrders();
            
            if (orders.length === 0) {
                showAlert('warning', 'Aucun ordre', 'Aucun ordre optimal trouv√©');
                return;
            }
            
            let executed = 0;
            for (let order of orders) {
                if (portfolio.cash >= order.allocation) {
                    executeOptimalOrder(order.symbol, order.price, order.allocation, 
                                      order.targetPrice, order.stopLoss);
                    executed++;
                }
            }
            
            showAlert('success', 'Ordres ex√©cut√©s', `${executed} ordres optimaux ex√©cut√©s`);
        }

        // V√©rifier les stops et targets automatiquement
        function checkStopsAndTargets() {
            for (let position of portfolio.positions) {
                const savedPosition = localStorage.getItem(`position_${position.symbol}`);
                if (savedPosition) {
                    const targets = JSON.parse(savedPosition);
                    
                    // V√©rifier Stop Loss
                    if (position.currentPrice <= targets.stopLoss) {
                        showAlert('danger', 'Stop Loss atteint!', 
                            `${position.symbol} a atteint le stop loss. Vente automatique.`);
                        sellPosition(position.symbol);
                    }
                    // V√©rifier Target
                    else if (position.currentPrice >= targets.targetPrice) {
                        showAlert('success', 'Target atteint!', 
                            `${position.symbol} a atteint l'objectif. Prise de profits.`);
                        sellPosition(position.symbol);
                    }
                }
            }
        }

        // Show Alert
        function showAlert(type, title, message) {
            const container = document.getElementById('alertsContainer');
            const alert = document.createElement('div');
            alert.className = `alert alert-${type}`;
            alert.innerHTML = `<strong>${title}:</strong> ${message}`;
            container.appendChild(alert);
            setTimeout(() => alert.remove(), 5000);
        }

        // Update Time
        function updateTime() {
            document.getElementById('currentTime').textContent = new Date().toLocaleTimeString();
        }

        // Initialize - Enhanced with AI Analysis
        document.addEventListener('DOMContentLoaded', async function() {
            console.log('CoPilot Trading avec IA Pr√©dictive initialis√©');
            
            // Add market info section
            const marketInfoHTML = '<div id="marketInfo"></div>';
            document.querySelector('.main-header').insertAdjacentHTML('afterend', marketInfoHTML);
            
            // Add AI Dashboard
            const aiDashboardHTML = `
                <div class="card" style="margin-bottom: 20px;">
                    <div class="card-header">
                        <h2 class="card-title">ü§ñ IA Pr√©dictive - Analyse de Performance</h2>
                    </div>
                    <div id="aiDashboard" style="display: grid; grid-template-columns: repeat(auto-fit, minmax(150px, 1fr)); gap: 10px;">
                        <div style="text-align: center; padding: 15px; background: #f9fafb; border-radius: 8px;">
                            <div style="font-size: 11px; color: #6b7280;">Pr√©dictions Totales</div>
                            <div style="font-size: 24px; font-weight: 700;" id="totalPredictions">0</div>
                        </div>
                        <div style="text-align: center; padding: 15px; background: #f9fafb; border-radius: 8px;">
                            <div style="font-size: 11px; color: #6b7280;">Taux de Succ√®s</div>
                            <div style="font-size: 24px; font-weight: 700;" id="successRate">0%</div>
                        </div>
                        <div style="text-align: center; padding: 15px; background: #f9fafb; border-radius: 8px;">
                            <div style="font-size: 11px; color: #6b7280;">Profit IA</div>
                            <div style="font-size: 24px; font-weight: 700;" id="aiProfit">‚Ç¨0</div>
                        </div>
                        <div style="text-align: center; padding: 15px; background: #f9fafb; border-radius: 8px;">
                            <div style="font-size: 11px; color: #6b7280;">Meilleur Trade</div>
                            <div style="font-size: 24px; font-weight: 700;" id="bestTrade">--</div>
                        </div>
                    </div>
                </div>
            `;
            document.querySelector('.container').insertAdjacentHTML('afterbegin', aiDashboardHTML);
            
            // Update time
            setInterval(updateTime, 1000);
            updateTime();
            
            // Initial scan with all data sources
            await scanMarket();
            await fetchMarketGlobal();
            
            // Update AI Dashboard
            updateAIDashboard();
            
            // Auto refresh every 30 seconds
            setInterval(async () => {
                await scanMarket();
                checkStopsAndTargets(); // V√©rifier stops et targets
                updateAIDashboard();
            }, CONFIG.UPDATE_INTERVAL);
            
            setInterval(fetchMarketGlobal, 60000); // Global data every minute
            
            // Load saved portfolio
            const saved = localStorage.getItem('portfolio');
            if (saved) {
                portfolio = JSON.parse(saved);
                updatePortfolio();
            }
            
            // Save portfolio periodically
            setInterval(() => {
                localStorage.setItem('portfolio', JSON.stringify(portfolio));
            }, 5000);
            
            // Message de bienvenue avec analyse
            const history = Object.keys(marketData.dailyHistory).length;
            if (history > 0) {
                showAlert('success', 'IA Activ√©e', 
                    `Syst√®me pr√™t avec ${history} jours d'historique. Analyse pr√©dictive en cours...`);
            } else {
                showAlert('info', 'Premi√®re utilisation', 
                    'Le syst√®me va commencer √† collecter des donn√©es pour am√©liorer les pr√©dictions');
            }
        });

        // Update AI Dashboard
        function updateAIDashboard() {
            const predictions = JSON.parse(localStorage.getItem('predictionHistory')) || [];
            const successRate = aiAnalysis.calculateSuccessRate();
            
            // Calculer le profit des trades IA
            const aiTrades = portfolio.transactions.filter(t => t.aiGenerated);
            const aiProfit = aiTrades.reduce((sum, t) => sum + (t.pl || 0), 0);
            
            // Meilleur trade
            const bestTrade = portfolio.transactions
                .filter(t => t.pl > 0)
                .sort((a, b) => b.pl - a.pl)[0];
            
            document.getElementById('totalPredictions').textContent = predictions.length;
            document.getElementById('successRate').textContent = `${successRate.rate.toFixed(1)}%`;
            document.getElementById('aiProfit').textContent = `‚Ç¨${aiProfit.toFixed(2)}`;
            document.getElementById('aiProfit').className = aiProfit >= 0 ? 'positive' : 'negative';
            document.getElementById('bestTrade').textContent = bestTrade ? 
                `${bestTrade.symbol} +${bestTrade.pl.toFixed(2)}‚Ç¨` : '--';
        }

        // Handle Enter key in search
        document.addEventListener('keypress', function(e) {
            if (e.key === 'Enter' && document.activeElement.id === 'searchInput') {
                searchAsset();
            }
        });
    </script>
</body>
</html>
